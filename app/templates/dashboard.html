<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Scalper Dashboard</title>
<style>
:root{ --bg:#0b1020; --card:#0e1420; --line:#1f2937; --fg:#e7ecf5; --muted:#93a0b8; --pos:#22c55e; --neg:#ef4444; --warn:#f59e0b; }
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.5 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
.container{max-width:1280px;margin:0 auto;padding:16px}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
.badge{color:var(--muted);font-size:12px}
.card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:12px;margin-bottom:14px}
.card h2{margin:0 0 8px;font-size:16px}
.hint{color:var(--muted);font-size:12px}
.table-responsive{overflow:auto}
.table-compact{width:100%;border-collapse:separate;border-spacing:0}
.table-compact th,.table-compact td{padding:6px 8px;border-bottom:1px solid var(--line);text-align:left;vertical-align:middle}
.table-compact thead th{position:sticky;top:0;background:#0f1626;z-index:1}
.table-compact tr:hover td{background:#0f172a}
.num{text-align:right}
.pnl-pos{color:var(--pos);font-weight:700}
.pnl-neg{color:var(--neg);font-weight:700}
.muted{color:var(--muted)}
.mono{font-variant-numeric:tabular-nums}
.ok{color:var(--pos);font-weight:600}
.bad{color:var(--neg);font-weight:600}
.warn{color:var(--warn);font-weight:600}
.chip{padding:.1rem .35rem;border-radius:.35rem;background:#111827;border:1px solid #1f2937}
.chip.num{font-variant-numeric:tabular-nums}
/* KPI */
.kpis{display:grid;gap:10px;grid-template-columns:repeat(7,1fr);margin-bottom:16px}
.kpi{background:#0e1420;border:1px solid var(--line);border-radius:12px;padding:12px}
.kpi .label{color:var(--muted);font-size:12px;margin-bottom:6px}
.kpi .value{font-size:22px;font-weight:700}
@media(max-width:1100px){.kpis{grid-template-columns:repeat(3,1fr)}}
@media(max-width:700px){.kpis{grid-template-columns:repeat(2,1fr)}}
/* SIGNALS */
.sig-long{ color: var(--pos); font-weight:700 }
.sig-short{ color: var(--neg); font-weight:700 }
.sig-raw{ color: var(--muted); font-weight:700 }
.rule-pass{ background:#0b2a15; border-color:#16452a; color:#b7f0c3 }
.rule-warn{ background:#2a210b; border-color:#4a3c13; color:#f0e0b7 }
.rule-fail{ background:#2a0b0b; border-color:#4a1717; color:#f0b7b7 }
/* Toast */
.toast{position:fixed;right:16px;bottom:16px;background:#0c111b;border:1px solid #223049;color:#e8eaf0;padding:10px 12px;border-radius:10px;opacity:0;transform:translateY(8px);transition:all .2s}
.toast.show{opacity:1;transform:translateY(0)}
.btn{background:#111827;border:1px solid var(--line);color:var(--fg);border-radius:10px;padding:8px 10px;font-weight:600;cursor:pointer}
.btn:hover{filter:brightness(1.1)}
.input{background:#0f172a;border:1px solid var(--line);color:var(--fg);border-radius:8px;padding:6px 8px;width:120px}
.code{white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;background:#0f1626;border:1px solid var(--line);border-radius:10px;padding:10px;color:#cfe3ff}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>Scalper Dashboard</h1>
    <div class="badge">
      <span id="symbolsBadge">—</span> ·
      <span id="streamBadge">—</span> ·
      DB: <span id="dbSize">—</span> ·
      <span id="clock"></span>
    </div>
  </div>

  <!-- KPI BAR -->
  <div class="kpis">
    <div class="kpi"><div class="label">Toplam Long (kapandı)</div><div class="value" id="kpiLong">0</div></div>
    <div class="kpi"><div class="label">Toplam Short (kapandı)</div><div class="value" id="kpiShort">0</div></div>
    <div class="kpi"><div class="label">Başarılı (Kârlı) İşlem</div><div class="value ok" id="kpiWins">0</div></div>
    <div class="kpi"><div class="label">Başarısız (Zararlı) İşlem</div><div class="value bad" id="kpiLosses">0</div></div>
    <div class="kpi"><div class="label">Başarı Oranı</div><div class="value" id="kpiWinRate">0%</div></div>
    <div class="kpi"><div class="label">Toplam PNL</div><div class="value" id="kpiTotalPNL">$0.00</div></div>
    <div class="kpi"><div class="label">Toplam İşlem</div><div class="value" id="kpiTotalTrades">0</div></div>
  </div>

  <!-- Manual Trade -->
  <div class="card">
    <h2>Manual Trade</h2>
    <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:flex-end">
      <div>
        <div class="label muted">Symbol</div>
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <input id="symbolInput" class="input" value="ETHUSDT" />
          <div class="hint">Hızlı:</div>
          <button class="btn" onclick="setSymbol('ETHUSDT')">ETHUSDT</button>
          <button class="btn" onclick="setSymbol('BTCUSDT')">BTCUSDT</button>
        </div>
      </div>
      <div><div class="label muted">Leverage</div><input id="levInput" class="input" type="number" value="10" /></div>
      <div><div class="label muted">Margin (USD)</div><input id="marginInput" class="input" type="number" value="10" /></div>
      <div style="display:flex;gap:8px">
        <button class="btn" onclick="manualOpen('long')">Open LONG</button>
        <button class="btn" onclick="manualOpen('short')">Open SHORT</button>
        <button class="btn" onclick="manualClose()">Close</button>
      </div>
    </div>
  </div>

  <!-- Open Positions -->
  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <h2>Open Positions</h2>
      <div class="hint">Canlı pozisyonlar</div>
    </div>
    <div class="table-responsive">
      <table class="table-compact" id="posTable">
        <thead><tr>
          <th>Symbol</th><th>Side</th>
          <th class="num">Qty</th><th class="num">Entry</th><th class="num">Liq</th><th class="num">Last</th>
          <th class="num">PNL $</th><th class="num">Notional</th><th class="num">Lev</th><th></th>
        </tr></thead>
        <tbody id="posBody"><tr class="muted"><td colspan="10">Bekleniyor…</td></tr></tbody>
      </table>
    </div>
    <div class="hint" style="margin-top:8px">PnL $ = (Price-Entry)×Qty (long) / (Entry-Price)×Qty (short). Notional = Entry×Qty.</div>
  </div>

  <!-- Signals (live) -->
  <div class="card">
    <h2>Signals (live)</h2>
    <div class="hint" style="margin-bottom:8px">
      Tick/s ≥ <b>{{ thresholds.MIN_TICKS_PER_SEC|default(2.0) }}</b>, Spread bps ≤ <b>{{ thresholds.MAX_SPREAD_BPS|default(5) }}</b>,
      Buy/SellPress ≥ <b>{{ thresholds.BUY_PRESSURE_MIN|default(0.55) }}</b>,
      Imbalance long ≥ <b>1.25</b> / short ≤ <b>0.80</b>,
      ATR ∈ [<b>{{ thresholds.ATR_MIN|default(0.0002) }}</b>, <b>{{ thresholds.ATR_MAX|default(0.05) }}</b>],
      VWAP sapma ≤ <b>0.20%</b>, VolSpike > <b>1.5x</b>, Funding > <b>20dk</b>, Yakın S/R yok (±0.15%).
    </div>
    <div class="table-responsive">
      <table class="table-compact" style="width:100%">
        <thead>
          <tr>
            <th>Time</th><th>Symbol</th><th>Signal</th>
            <th class="num">Price</th><th class="num">EMAf</th><th class="num">EMAs</th><th class="num">RSI14</th>
            <th class="num">VWAP (60s)</th><th class="num">ATR (60s)</th>
            <th class="num">Tick/s</th><th class="num">Spread bps</th><th class="num">Press</th><th class="num">Imb</th>
            <th class="num">VolSpike</th><th class="num">CVD 10m</th><th>Funding&gt;20m</th><th>Yakın S/R</th>
            <th>Rules</th>
          </tr>
        </thead>
        <tbody id="signalsTBody"><tr class="muted"><td colspan="18">Bekleniyor…</td></tr></tbody>
      </table>
    </div>
    <details id="signalsDetails" style="margin-top:10px"><summary>Ham JSON</summary>
      <pre id="signalsBox" class="mono code" style="max-height:280px;overflow:auto;margin-top:8px">—</pre>
    </details>
  </div>

  <!-- Debug -->
  <div class="card">
    <h2>Debug</h2>
    <div class="hint">Endpoint ham cevapları ve son hatalar</div>
    <details open style="margin-top:8px">
      <summary>/healthz</summary>
      <pre id="dbgHealth" class="code">—</pre>
    </details>
    <details style="margin-top:8px">
      <summary>/positions</summary>
      <pre id="dbgPositions" class="code">—</pre>
    </details>
    <details style="margin-top:8px">
      <summary>/signals</summary>
      <pre id="dbgSignals" class="code">—</pre>
    </details>
    <div class="hint" id="dbgError">Son hata: —</div>
  </div>

  <!-- History -->
  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <h2>History (Last 100 / DB 10,000)</h2>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="btn" id="btnClearHistory">Clear History</button>
        <span class="hint">Gösterim 100; KPI & özet 10,000</span>
      </div>
    </div>
    <div class="table-responsive">
      <table class="table-compact" id="histTable">
        <thead><tr>
          <th>Symbol</th><th>Side</th>
          <th class="num">Qty</th><th class="num">Entry</th><th class="num">Exit</th>
          <th class="num">PNL</th><th class="num">Fee (USD)</th><th class="num">Net PNL</th>
          <th class="num">Lev</th><th class="num">Margin</th>
          <th class="num">Notional</th><th class="num">Liq</th>
          <th class="num">Opened</th><th class="num">Closed</th>
        </tr></thead>
        <tbody id="histBody"><tr class="muted"><td colspan="14">Bekleniyor…</td></tr></tbody>
      </table>
    </div>
  </div>
</div>

<div id="toast" class="toast">—</div>

<script>
/*** ---------- GLOBAL STATE & CONFIG ---------- ***/
let lastPrices = {};               // canlı fiyat cache (signals'tan)
let currentSymbols = [];           // healthz -> symbols
let signalsRowCache = new Map();   // symbol -> <tr>
let positionsRowCache = new Map(); // symbol -> <tr>
let historyLastHash = "";          // gereksiz render önleme
let signalsLastHash = "";          // gereksiz render önleme
let dbgSignalsTick = 0;

let ctrlSignals = null, ctrlPositions = null, ctrlHistory = null;

const fmt2 = v => (v==null||Number.isNaN(v))?'-':Number(v).toFixed(2);
const fmt4 = v => (v==null||Number.isNaN(v))?'-':Number(v).toFixed(4);
const fmtQ = v => (v==null||Number.isNaN(v))?'-':Number(v).toFixed(6);
const clsP = v => (v||0) >= 0 ? 'pnl-pos' : 'pnl-neg';
function toast(msg){ const el=document.getElementById('toast'); el.textContent=msg; el.classList.add('show'); clearTimeout(window.__t); window.__t=setTimeout(()=>el.classList.remove('show'), 1800); }
function setSymbol(sym){ const el=document.getElementById('symbolInput'); el.value=sym; toast(`Symbol: ${sym}`); }

const TH = {
  MIN_TICKS_PER_SEC: {{ thresholds.MIN_TICKS_PER_SEC|default(2.0) }},
  MAX_SPREAD_BPS: {{ thresholds.MAX_SPREAD_BPS|default(5) }},
  BUY_PRESSURE_MIN: {{ thresholds.BUY_PRESSURE_MIN|default(0.55) }},
  IMB_LONG_MIN: 1.25,
  IMB_SHORT_MAX: 0.80,
  ATR_MIN: {{ thresholds.ATR_MIN|default(0.0002) }},
  ATR_MAX: {{ thresholds.ATR_MAX|default(0.05) }},
  VWAP_DEV_MAX: 0.002,
  VOL_SPIKE_MIN: 1.5,
  FUNDING_MIN_MIN: 20,
};
const FEE_RATE = {{ fee_rate|default(0.0004) }};

const pick = (o, ...keys) => {
  for (const k of keys) {
    if (o==null) continue;
    if (k in o) return o[k];
    const alt = k.includes('_')
      ? k.replace(/_([a-z])/g, (_,c)=>c.toUpperCase())
      : k.replace(/[A-Z]/g, c=>'_'+c.toLowerCase());
    if (alt in o) return o[alt];
  }
  return undefined;
};

function extractArray(j, preferredKeys=[]){
  if (Array.isArray(j)) return j;
  if (j && typeof j==='object'){
    for(const k of preferredKeys){ if (Array.isArray(j[k])) return j[k]; }
    for(const v of Object.values(j)){ if (Array.isArray(v)) return v; }
  }
  return [];
}
function mapToArrayBySymbol(obj){
  if (!obj || Array.isArray(obj) || typeof obj !== 'object') return [];
  return Object.entries(obj).map(([symbol, payload]) => ({ symbol, ...(payload||{}) }));
}

function safeNum(x){ const n = Number(x); return Number.isFinite(n) ? n : 0; }
function estimateFeeUSD(row){
  if (row.fee_total_usd!=null && !Number.isNaN(row.fee_total_usd)) return Number(row.fee_total_usd);
  const qty = safeNum(row.qty);
  const openN = safeNum(row.entry) * qty;
  const closeN= safeNum(row.exit)  * qty;
  return (openN + closeN) * FEE_RATE;
}
function netPnlUSD(row){
  if (row.net_pnl!=null && !Number.isNaN(row.net_pnl)) return Number(row.net_pnl);
  const pnl = safeNum(row.pnl);
  return pnl - estimateFeeUSD(row);
}

/*** ---------- NORMALIZERS ---------- ***/
function normalizePosition(p){
  return {
    symbol: pick(p,'symbol'),
    side: pick(p,'side'),
    qty: Number(pick(p,'qty','quantity')),
    entry: Number(pick(p,'entry','entry_price')),
    liq_price: Number(pick(p,'liq_price','liq','liquidation_price')),
    last_price: Number(pick(p,'last_price','price','last','lastPrice')),
    pnl: Number(pick(p,'pnl','pnl_usd')),
    notional_usd: Number(pick(p,'notional_usd','notional')),
    leverage: Number(pick(p,'leverage','lev'))
  };
}
function normalizeHistoryRow(x){
  return {
    symbol: pick(x,'symbol'),
    side: pick(x,'side'),
    qty: Number(pick(x,'qty','quantity')),
    entry: Number(pick(x,'entry','entry_price')),
    exit: Number(pick(x,'exit','exit_price','close')),
    pnl: Number(pick(x,'pnl','pnl_usd')),
    fee_total_usd: Number(pick(x,'fee_total_usd','fees_usd','fee_usd')),
    net_pnl: Number(pick(x,'net_pnl','net')),
    leverage: Number(pick(x,'leverage','lev')),
    margin_usd: Number(pick(x,'margin_usd','margin')),
    notional_usd: Number(pick(x,'notional_usd','notional')),
    liq_price: Number(pick(x,'liq_price','liquidation_price')),
    opened_at: pick(x,'opened_at','opened','open_time'),
    closed_at: pick(x,'closed_at','closed','close_time')
  };
}
function normalizeSignal(s){
  const lp = Number(pick(s,'last_price','price','last'));
  const vwap = Number(pick(s,'vwap60','vwap'));
  const emaf = Number(pick(s,'ema_fast','emaf'));
  const emas = Number(pick(s,'ema_slow','emas'));
  const rsi = Number(pick(s,'rsi14','rsi'));
  const atr = Number(pick(s,'atr60','atr'));
  const tps = Number(pick(s,'tick_rate_2s','tick_rate','ticks_per_sec'));
  const spr = Number(pick(s,'spread_bps','spread'));
  const bp  = Number(pick(s,'buy_pressure_2s','buy_pressure','bp'));
  const sp  = Number(pick(s,'sell_pressure_2s','sell_pressure'));
  const imb = Number(pick(s,'imbalance','imb'));
  const symbol = pick(s,'symbol');
  const ts = pick(s,'ts','time','timestamp','last_ts');
  const volSpike = Number(pick(s,'vol_spike_5s','volume_spike'));
  const cvd10 = Number(pick(s,'cvd_10m','cvd10m','cvd10'));
  const fundingGap = Number(pick(s,'funding_gap_min','funding_min','fundingGapMin'));
  const srFlag = !!pick(s,'nearby_sr_flag','nearbySR','nearby_sr');
  return {
    ts, symbol,
    last_price:lp, vwap60:vwap,
    ema_fast:emaf, ema_slow:emas, rsi14:rsi, atr60:atr,
    tick_rate_2s:tps, spread_bps:spr,
    buy_pressure_2s:bp, sell_pressure_2s:sp,
    imbalance:imb,
    volume_spike:volSpike, cvd_10m:cvd10, funding_gap_min:fundingGap, nearby_sr_flag:srFlag,
    side: pick(s,'side')
  };
}

/*** ---------- SIGNAL RULES ---------- ***/
function sideClass(side){ if(!side) return 'sig-raw'; return side==='long'?'sig-long':(side==='short'?'sig-short':'sig-raw'); }
function sideLabel(side){ return side? side.toUpperCase() : 'RAW'; }
function ruleBadge(status){
  const map={ pass:{cls:'rule-pass',text:'PASS'}, warn:{cls:'rule-warn',text:'WARN'}, fail:{cls:'rule-fail',text:'FAIL'} };
  const m = map[status] ?? map.fail; return `<span class="chip ${m.cls}">${m.text}</span>`;
}
function asPct(x,d=1){ return (x==null)?'-':(x*100).toFixed(d)+'%'; }

function evalRules(row){
  const lp=row.last_price, v=row.vwap60;
  const vDev = (v&&lp)?Math.abs(lp-v)/v:null;

  const baseOk =
    (row.tick_rate_2s??0) >= TH.MIN_TICKS_PER_SEC &&
    (row.spread_bps??Infinity) <= TH.MAX_SPREAD_BPS &&
    (row.atr60!=null && row.atr60>=TH.ATR_MIN && row.atr60<=TH.ATR_MAX) &&
    (vDev!=null && vDev<=TH.VWAP_DEV_MAX) &&
    (row.volume_spike!=null && row.volume_spike>TH.VOL_SPIKE_MIN) &&
    (row.funding_gap_min!=null && row.funding_gap_min>TH.FUNDING_MIN_MIN) &&
    (row.nearby_sr_flag===false);

  let side = row.side;
  if(!side){
    const ef=row.ema_fast, es=row.ema_slow, bp=row.buy_pressure_2s;
    if(ef!=null && es!=null && bp!=null){
      if(ef>es && bp>=0.55 && (row.rsi14==null || row.rsi14<70)) side='long';
      else if(ef<es && bp<=0.45 && (row.rsi14==null || row.rsi14>30)) side='short';
    }
  }

  let specificOk=false;
  if(side==='long'){
    const pressOk = (row.buy_pressure_2s!=null && row.buy_pressure_2s>=0.55);
    const imbOk   = (row.imbalance!=null && row.imbalance>=TH.IMB_LONG_MIN);
    const cvdOk   = (row.cvd_10m!=null && row.cvd_10m>0);
    specificOk = pressOk && imbOk && cvdOk;
  }else if(side==='short'){
    const sellP = (row.sell_pressure_2s!=null) ? row.sell_pressure_2s
                  : (row.buy_pressure_2s!=null ? (1-row.buy_pressure_2s) : null);
    const pressOk = (sellP!=null && sellP>=0.55);
    const imbOk   = (row.imbalance!=null && row.imbalance<=TH.IMB_SHORT_MAX);
    const cvdOk   = (row.cvd_10m!=null && row.cvd_10m<0);
    specificOk = pressOk && imbOk && cvdOk;
  } else {
    specificOk = false;
  }

  const pass = baseOk && specificOk;
  const warn = baseOk && !specificOk;
  return {side, pass, warn};
}

/*** ---------- RENDER HELPERS (PATCH) ---------- ***/
function ensureSignalsHeaderCleared(){
  const tb=document.getElementById('signalsTBody');
  if (tb && tb.firstElementChild && tb.firstElementChild.classList.contains('muted')) {
    tb.innerHTML = '';
  }
}
function upsertSignalRow(s){
  const tb=document.getElementById('signalsTBody');
  ensureSignalsHeaderCleared();
  let tr = signalsRowCache.get(s.symbol);
  const {side, pass, warn} = evalRules(s);
  const sideTxt = sideLabel(side);
  const sideCls = sideClass(side);
  const lp=s.last_price, v=s.vwap60;
  const vDev=(v&&lp)?Math.abs(lp - v)/v:null;

  const tickOk=((s.tick_rate_2s??0)>=TH.MIN_TICKS_PER_SEC);
  const sprdOk=((s.spread_bps??Infinity)<=TH.MAX_SPREAD_BPS);
  const atrOk=(s.atr60!=null && s.atr60>=TH.ATR_MIN && s.atr60<=TH.ATR_MAX);
  const vwapOk=(vDev!=null && vDev<=TH.VWAP_DEV_MAX);
  const press = (side==='short')
      ? (s.sell_pressure_2s!=null ? s.sell_pressure_2s : (s.buy_pressure_2s!=null ? 1-s.buy_pressure_2s : null))
      : s.buy_pressure_2s;
  const pressCls=(press==null)?'':(press>=0.55?'ok':(press>=0.50?'warn':'bad'));

  const imbCls=(side==='short')
      ? (s.imbalance!=null ? (s.imbalance<=TH.IMB_SHORT_MAX?'ok':'bad') : '')
      : (s.imbalance!=null ? (s.imbalance>=TH.IMB_LONG_MIN?'ok':'bad') : '');

  const volCls=(s.volume_spike!=null)?(s.volume_spike>TH.VOL_SPIKE_MIN?'ok':'bad'):'';
  const cvdCls=(s.cvd_10m!=null)?((side==='short')?(s.cvd_10m<0?'ok':'bad'):(s.cvd_10m>0?'ok':'bad')):'';
  const fundOk=(s.funding_gap_min!=null && s.funding_gap_min>TH.FUNDING_MIN_MIN);
  const srOk=(s.nearby_sr_flag===false);
  const rulePill = pass?ruleBadge('pass'):(warn?ruleBadge('warn'):ruleBadge('fail'));
  const pressVal = press!=null ? asPct(press,1) : '-';

  if(!tr){
    tr = document.createElement('tr');
    tr.id = `sig-${s.symbol}`;
    tr.innerHTML = `
      <td data-f="ts"></td>
      <td data-f="symbol"></td>
      <td data-f="side"></td>
      <td class="num mono" data-f="price"></td>
      <td class="num mono" data-f="emaf"></td>
      <td class="num mono" data-f="emas"></td>
      <td class="num mono" data-f="rsi"></td>
      <td class="num mono" data-f="vwap"></td>
      <td class="num mono" data-f="atr"></td>
      <td class="num mono" data-f="tick"></td>
      <td class="num mono" data-f="sprd"></td>
      <td class="num mono" data-f="press"></td>
      <td class="num mono" data-f="imb"></td>
      <td class="num mono" data-f="vol"></td>
      <td class="num mono" data-f="cvd"></td>
      <td data-f="fund"></td>
      <td data-f="sr"></td>
      <td data-f="rule"></td>`;
    tb.appendChild(tr);
    signalsRowCache.set(s.symbol, tr);
  }
  const q=(k)=>tr.querySelector(`[data-f="${k}"]`);
  q('ts').textContent = s.ts || '-';
  q('symbol').textContent = s.symbol || '-';
  q('side').innerHTML = `<span class="${sideCls}">${sideTxt}</span>`;
  q('price').textContent = lp!=null ? fmt4(lp) : '-';
  q('emaf').textContent = s.ema_fast!=null ? fmt4(s.ema_fast) : '-';
  q('emas').textContent = s.ema_slow!=null ? fmt4(s.ema_slow) : '-';
  q('rsi').textContent = s.rsi14!=null ? fmt2(s.rsi14) : '-';
  q('vwap').textContent = v!=null ? fmt4(v) : '-';
  q('atr').textContent = s.atr60!=null ? fmt4(s.atr60) : '-';
  q('tick').textContent = s.tick_rate_2s!=null ? fmt2(s.tick_rate_2s) : '-';
  q('sprd').textContent = s.spread_bps!=null ? fmt2(s.spread_bps) : '-';
  q('press').textContent = pressVal;
  q('imb').textContent = s.imbalance!=null ? fmt2(s.imbalance) : '-';
  q('vol').textContent = s.volume_spike!=null ? fmt2(s.volume_spike) : '-';
  q('cvd').textContent = s.cvd_10m!=null ? fmt2(s.cvd_10m) : '-';
  q('fund').innerHTML = fundOk?'<span class="ok">OK</span>':'<span class="warn">YAKIN</span>';
  q('sr').innerHTML = srOk?'<span>YOK</span>':'<span class="warn">VAR</span>';
  q('rule').innerHTML = rulePill;

  // sınıf patch
  q('press').className = `num mono ${pressCls}`;
  q('imb').className = `num mono ${imbCls}`;
  q('tick').className = `num mono ${tickOk?'ok':'bad'}`;
  q('sprd').className = `num mono ${sprdOk?'ok':'bad'}`;
  q('atr').className  = `num mono ${atrOk?'ok':'bad'}`;
  q('vwap').className = `num mono ${vwapOk?'ok':'bad'}`;
}

function ensurePositionsHeaderCleared(){
  const tb=document.getElementById('posBody');
  if (tb && tb.firstElementChild && tb.firstElementChild.classList.contains('muted')) {
    tb.innerHTML = '';
  }
}
function upsertPositionRow(p){
  const tb=document.getElementById('posBody');
  ensurePositionsHeaderCleared();
  let tr = positionsRowCache.get(p.symbol);
  if(!tr){
    tr = document.createElement('tr');
    tr.id = `pos-${p.symbol}`;
    tr.innerHTML = `
      <td data-f="symbol"></td>
      <td data-f="side"></td>
      <td class="num mono" data-f="qty"></td>
      <td class="num mono" data-f="entry"></td>
      <td class="num mono" data-f="liq"></td>
      <td class="num mono" data-f="last"></td>
      <td class="num mono" data-f="pnl"></td>
      <td class="num mono" data-f="notional"></td>
      <td class="num mono" data-f="lev"></td>
      <td class="num" data-f="btn"></td>`;
    tb.appendChild(tr);
    positionsRowCache.set(p.symbol, tr);
  }
  const q=(k)=>tr.querySelector(`[data-f="${k}"]`);
  q('symbol').textContent = p.symbol||'-';
  q('side').textContent   = p.side||'-';
  q('qty').textContent    = fmtQ(p.qty);
  q('entry').textContent  = fmt4(p.entry);
  q('liq').textContent    = fmt4(p.liq_price);
  q('last').textContent   = fmt4(p.last_price);
  q('pnl').textContent    = fmt2(p.pnl);
  q('pnl').className      = `num mono ${clsP(p.pnl)}`;
  q('notional').textContent = fmt2(p.notional_usd);
  q('lev').textContent    = p.leverage||'-';
  q('btn').innerHTML      = `<button class="btn" onclick="closeSymbol('${p.symbol}')">Close</button>`;
}

/*** ---------- LOADERS (with Abort + batching) ---------- ***/
async function loadHealth(){
  try{
    const r = await fetch('/healthz',{cache:'no-store'});
    const j = await r.json();
    document.getElementById('dbgHealth').textContent = JSON.stringify(j,null,2);
    const syms = j?.symbols;
    if (Array.isArray(syms) && syms.length){
      currentSymbols = syms;
      document.getElementById('symbolsBadge').textContent = syms.join(', ');
    }
    document.getElementById('streamBadge').textContent = j?.stream || '—';
  }catch(e){
    document.getElementById('dbgHealth').textContent = JSON.stringify({error: e?.message||'healthz'}, null, 2);
  }
}

async function loadSignals(){
  if (ctrlSignals) ctrlSignals.abort();
  ctrlSignals = new AbortController();
  const tb=document.getElementById('signalsTBody');
  try{
    const r=await fetch('/signals',{cache:'no-store', signal: ctrlSignals.signal});
    const j=await r.json();
    // debug JSON'u yalnızca detay açıkken ve 2sn'de bir yaz
    if (document.getElementById('signalsDetails').open) {
      if ((dbgSignalsTick++ % 2) === 0) {
        document.getElementById('dbgSignals').textContent = JSON.stringify(j,null,2);
      }
    }
    let raw = Array.isArray(j) ? j : extractArray(j, ['rows','data','signals','ticks','items']);
    if (!Array.isArray(raw) || raw.length===0) raw = mapToArrayBySymbol(j);

    const sigs = raw.map(normalizeSignal);
    // küçük bir hash ile değişmedi ise render etme
    const nextHash = JSON.stringify(sigs.map(s=>[s.symbol,s.ts,s.last_price,s.ema_fast,s.ema_slow]));
    if (nextHash === signalsLastHash) return;
    signalsLastHash = nextHash;

    // canlı fiyat cache
    lastPrices = {};
    for (const s of sigs) {
      if (s.symbol && Number.isFinite(s.last_price)) lastPrices[s.symbol] = Number(s.last_price);
      upsertSignalRow(s);
    }

    // ham json (heavy) — sadece details açıkken formatla
    if (document.getElementById('signalsDetails').open) {
      document.getElementById('signalsBox').textContent = JSON.stringify(sigs,null,2);
    }
  }catch(e){
    if (e.name === 'AbortError') return;
    tb.innerHTML = `<tr class="muted"><td colspan="18">Yüklenemedi.</td></tr>`;
    document.getElementById('dbgSignals').textContent = 'Hata: '+ (e?.message||e);
    setLastError(`Signals error: ${e?.message||e}`);
  }
}

async function loadPositions(){
  if (ctrlPositions) ctrlPositions.abort();
  ctrlPositions = new AbortController();
  const body=document.getElementById('posBody');

  async function tryFetch(url){
    try{
      const r = await fetch(url,{cache:'no-store', signal: ctrlPositions.signal});
      if (!r.ok) return null;
      return await r.json();
    }catch{ return null; }
  }

  try{
    const candidates = ['/paper/positions','/positions','/open_positions','/account/positions'];
    let j = null;
    for(const path of candidates){ j = await tryFetch(path); if (j) break; }
    if (!j){
      document.getElementById('dbgPositions').textContent = JSON.stringify({detail:"Not Found"}, null, 2);
      body.innerHTML = `<tr class="muted"><td colspan="10">Endpoint bulunamadı (/paper/positions, /positions, /open_positions, /account/positions).</td></tr>`;
      return;
    }

    // satır-bazlı patch
    let raw = null;
    if (!Array.isArray(j) && j && typeof j === 'object' && j.open && typeof j.open === 'object') {
      raw = mapToArrayBySymbol(j.open);
    } else if (Array.isArray(j)) {
      raw = j;
    } else {
      raw = extractArray(j, ['rows','data','positions','openPositions','items']);
      if (!Array.isArray(raw) || raw.length===0) raw = mapToArrayBySymbol(j);
    }
    raw = (raw||[]).filter(r => {
      const hasCore = r && (r.symbol || r.side || r.entry!=null || r.qty!=null);
      return !!hasCore && r.symbol !== 'open' && r.symbol !== 'closed_count';
    });
    const rows = raw.map(normalizePosition);
    if (body && body.firstElementChild && body.firstElementChild.classList.contains('muted')) {
      body.innerHTML = '';
    }
    const seen = new Set();
    for (const r of rows){
      if ((r.last_price==null || Number.isNaN(r.last_price)) && r.symbol && lastPrices[r.symbol]!=null) {
        r.last_price = lastPrices[r.symbol];
      }
      if (r.notional_usd==null || Number.isNaN(r.notional_usd)) {
        if (r.entry!=null && r.qty!=null) r.notional_usd = r.entry * r.qty;
      }
      if (r.pnl==null || Number.isNaN(r.pnl)) {
        if (r.entry!=null && r.qty!=null && r.last_price!=null) {
          r.pnl = (r.side==='short')? (r.entry - r.last_price) * r.qty : (r.last_price - r.entry) * r.qty;
        }
      }
      seen.add(r.symbol);
      upsertPositionRow(r);
    }
    // kapatılan semboller satırlarını temizle
    for (const sym of positionsRowCache.keys()){
      if (!seen.has(sym)){
        const tr = positionsRowCache.get(sym);
        if (tr && tr.parentNode) tr.parentNode.removeChild(tr);
        positionsRowCache.delete(sym);
      }
    }
  }catch(e){
    if (e.name === 'AbortError') return;
    body.innerHTML = `<tr class="muted"><td colspan="10">Yüklenemedi.</td></tr>`;
    setLastError(`Positions error: ${e?.message||e}`);
  }
}

async function loadHistory(limit=100){
  if (ctrlHistory) ctrlHistory.abort();
  ctrlHistory = new AbortController();
  const body=document.getElementById('histBody');
  try{
    const r=await fetch(`/history?limit=${limit}`,{cache:'no-store', signal: ctrlHistory.signal});
    const j=await r.json();
    const raw=(j&&j.ok&&Array.isArray(j.rows))?j.rows:(Array.isArray(j)?j:extractArray(j,['rows','data','items']));
    const rows = raw.map(normalizeHistoryRow);

    // değişmediyse tabloyu elleme
    const hash = JSON.stringify(rows.map(x=>[x.symbol,x.side,x.entry,x.exit,x.pnl]));
    if (hash === historyLastHash) return;
    historyLastHash = hash;

    body.innerHTML='';
    if(rows.length===0){
      body.innerHTML = `<tr class="muted"><td colspan="14">Kayıt yok.</td></tr>`;
      return;
    }
    const frag = document.createDocumentFragment();
    for(const x of rows){
      const fee = estimateFeeUSD(x);
      const net = netPnlUSD(x);
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td>${x.symbol}</td>
        <td>${x.side}</td>
        <td class="num mono">${fmtQ(x.qty)}</td>
        <td class="num mono">${fmt4(x.entry)}</td>
        <td class="num mono">${fmt4(x.exit)}</td>
        <td class="num mono ${clsP(x.pnl)}">${fmt2(x.pnl)}</td>
        <td class="num mono">${fmt2(fee)}</td>
        <td class="num mono ${clsP(net)}">${fmt2(net)}</td>
        <td class="num mono">${x.leverage??'-'}</td>
        <td class="num mono">${fmt2(x.margin_usd)}</td>
        <td class="num mono">${fmt2(x.notional_usd)}</td>
        <td class="num mono">${fmt4(x.liq_price)}</td>
        <td class="num mono">${x.opened_at||'-'}</td>
        <td class="num mono">${x.closed_at||'-'}</td>`;
      frag.appendChild(tr);
    }
    body.appendChild(frag);

    // KPI'leri daha seyrek güncelle (history 10k ayrı fonksiyonda)
  }catch(e){
    if (e.name === 'AbortError') return;
    body.innerHTML = `<tr class="muted"><td colspan="14">Yüklenemedi.</td></tr>`;
    setLastError(`History error: ${e?.message||e}`);
  }
}

async function loadSummary(){
  try{
    const r=await fetch('/history?limit=10000',{cache:'no-store'});
    const j=await r.json();
    const arr = extractArray(j,['rows','data','items']) || [];
    computeKPIs(arr);
    const dbEl=document.getElementById('dbSize');
    if(dbEl) dbEl.textContent = String(Math.min(arr.length, 10000));
  }catch{ computeKPIs([]); }
}

function computeKPIs(rows){
  let longCnt=0, shortCnt=0, wins=0, losses=0, totalPNL=0;
  for(const raw of rows){
    const x = normalizeHistoryRow(raw);
    const side = x.side;
    if(side==='long') longCnt++; else if(side==='short') shortCnt++;
    const net = netPnlUSD(x);
    if(!Number.isNaN(net)){ totalPNL+=net; if(net>0) wins++; else if(net<0) losses++; }
  }
  const totalWL=wins+losses;
  const winRate= totalWL>0? (wins/totalWL*100).toFixed(1) : '0.0';
  document.getElementById('kpiLong').textContent=longCnt;
  document.getElementById('kpiShort').textContent=shortCnt;
  document.getElementById('kpiWins').textContent=wins;
  document.getElementById('kpiLosses').textContent=losses;
  document.getElementById('kpiWinRate').textContent=`${winRate}%`;
  const pnlEl=document.getElementById('kpiTotalPNL');
  pnlEl.textContent=`$${fmt2(totalPNL)}`;
  pnlEl.classList.remove('pnl-pos','pnl-neg');
  pnlEl.classList.add(totalPNL>=0?'pnl-pos':'pnl-neg');
  document.getElementById('kpiTotalTrades').textContent = (longCnt + shortCnt);
}

/*** ---------- UX HELPERS ---------- ***/
function setLastError(msg){ document.getElementById('dbgError').textContent = 'Son hata: ' + msg; toast(msg); }
function tickClock(){ document.getElementById('clock').textContent = new Date().toLocaleTimeString(); }
setInterval(tickClock, 1000); tickClock();

function getSymbol(){ return (document.getElementById('symbolInput').value||'ETHUSDT').trim(); }
function getLev(){ return Math.max(1, parseInt(document.getElementById('levInput').value||'10',10)); }
function getMargin(){ return Math.max(1, parseFloat(document.getElementById('marginInput').value||'10')); }

/*** ---------- ACTIONS ---------- ***/
async function manualOpen(side){
  const symbol=getSymbol();
  const payload={symbol, side, leverage:getLev(), margin_usd:getMargin()};
  try{
    const r=await fetch('/paper/order',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
    const j=await r.json();
    if(!r.ok || j.ok===false) throw new Error(j.error||'order_failed');
    toast(`✅ ${symbol} ${side.toUpperCase()} opened (lev=${payload.leverage}, margin=$${payload.margin_usd})`);
    loadPositions(); loadHistory(100);
    setTimeout(loadSummary, 300);
  }catch(e){ setLastError(`Order failed: ${e.message}`); }
}
async function manualClose(){
  const symbol=getSymbol();
  try{
    const r=await fetch('/paper/close',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({symbol})});
    const j=await r.json();
    if(!r.ok || j.ok===false) throw new Error(j.error||'close_failed');
    const c = j.closed||{};
    const row = { qty: c.qty, entry: c.entry, exit: c.exit, pnl: c.pnl, fee_total_usd: c.fee_total_usd, net_pnl: c.net_pnl };
    const fee = estimateFeeUSD(row);
    const net = netPnlUSD(row);
    toast(`ℹ️ ${symbol} closed. PnL=${fmt2(safeNum(c.pnl))}  Fee=${fmt2(fee)}  Net=${fmt2(net)}`);
    loadPositions(); loadHistory(100);
    setTimeout(loadSummary, 300);
  }catch(e){ setLastError(`Close failed: ${e.message}`); }
}
async function closeSymbol(symbol){ document.getElementById('symbolInput').value=symbol; await manualClose(); }
async function clearHistory(){
  try{
    const r=await fetch('/history/clear',{method:'POST'});
    const j=await r.json();
    if(!r.ok||j.ok===false) throw new Error(j.error||'clear_failed');
    toast('🧹 History cleared'); loadHistory(100); loadSummary();
  }catch(e){ setLastError(`Clear failed: ${e.message}`); }
}
document.getElementById('btnClearHistory').addEventListener('click', clearHistory);

/*** ---------- INIT & POLLING (optimized) ---------- ***/
async function init(){
  await loadHealth();
  await Promise.all([loadPositions(), loadSignals(), loadHistory(100), loadSummary()]);
}
init();

// Daha düşük frekanslı & çakışmasız polling
setInterval(loadSignals, 1500);
setInterval(loadPositions, 4000);
setInterval(()=>loadHistory(100), 12000);
setInterval(()=>loadSummary(), 30000);

// JSON box'u sadece açıkken güncelle
document.getElementById('signalsDetails').addEventListener('toggle', ()=>{
  if (document.getElementById('signalsDetails').open) {
    // Açılınca bir kere doldur
    loadSignals();
  } else {
    // Kapalıyken metni temizleyip GC
    document.getElementById('signalsBox').textContent = '—';
  }
});
</script>
</body>
</html>
